C++ language 



C  Language 

This graph plots input values (0 to 50) against compilation time (milliseconds) to demonstrate the performance of various algorithms.
and for plotting the grpah we set the y limit 0 to 0.05 because all the time values are incredibly very low excpet for the Recursive fibonacci it's exponentially growing.

saved the compilation time data in a text file and given the file as input in python to generate the graph with Matplotlib package .

1. The magnitude of the input causes the recursive Fibonacci method to take progressively longer to complete. The steeply rising curve that appears as the input size gets closer to 50 is indicative of this. For the recursive Fibonacci sequence, the time complexity is O(2 to the power of n)

2. fib iterative : Fibonacci Iterative: The iterative version of the Fibonacci sequence appears to have a time complexity that is linear or possibly constant, as indicated by the flat line near the x-axis. This suggests a time complexity of 
�
(
�
)
O(n) or 
�
(
1
)
O(1), respectively. Given the typical implementation of iterative Fibonacci, 
�
(
�
)
O(n) is the expected complexity.

Sum of Cubes Recursive: The time taken by the recursive sum of cubes seems to be relatively flat, suggesting that its time complexity is likely linear 
�
(
�
)
O(n), or possibly even constant 
�
(
1
)
O(1). However, since it's a sum of cubes, the expectation would be 
�
(
�
)
O(n) if the implementation involves a simple loop or recursion that sums the cubes of each number up to n.

Sum of Cubes Iterative: This also shows a flat line near the x-axis, which is indicative of a constant time complexity 
�
(
1
)
O(1) or linear 
�
(
�
)
O(n). It's more likely to be 
�
(
�
)
O(n) if it's simply summing the cubes of each number up to n.



